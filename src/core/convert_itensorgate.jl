"""
    to_itensor_op(gate::QuantumGate, sites)
convert a QuantumGate (SingleQubitGate, ControlledGate, etc.) to an ITensors operator using the provided site indices.
This function is overloaded for different gate types, allowing for a seamless mapping from our abstract gate representation to the concrete ITensor operators. The `sites` argument is expected to be a collection of site indices corresponding to the qubits in the circuit, typically obtained from `siteinds("Qubit", N)`.
The function handles various gate types, including single-qubit gates, controlled gates, and multi-qubit gates, as well as their parametric versions. It constructs the appropriate ITensor operator based on the gate type and its parameters, ensuring that the resulting operator can be directly applied to an MPS representing the quantum state.
"""
function to_itensor_op end
export to_itensor_op

# --- Single Qubit & Spin ---
function to_itensor_op(gate::SingleQubitGate, sites)
    return op(string(gate.gate_type), sites[gate.qubit])
end
function to_itensor_op(gate::ParametricSingleGate, sites)
    t = gate.gate_type
    p = gate.params
    if t in [:Rx, :Ry, :Rz, :RX, :RY, :RZ]
        return op(string(t), sites[gate.qubit]; θ=p[1])
    elseif t in [:Rn, :Rn̂]
        return op(string(t), sites[gate.qubit]; θ=p[1], ϕ=p[2], λ=p[3])
    elseif t in [:Phase, :P, :S]
        return op(string(t), sites[gate.qubit]; ϕ=p[1])
    end
    return op(string(t), sites[gate.qubit])
end

# --- Two Qubit ---
function to_itensor_op(gate::ControlledGate, sites)
    return op(string(gate.gate_type), sites[gate.control], sites[gate.target])
end
function to_itensor_op(gate::ParametricControlledGate, sites)
    t = gate.gate_type
    p = gate.params
    if t in [:CRx, :CRy, :CRz, :CRX, :CRY, :CRZ]
        return op(string(t), sites[gate.control], sites[gate.target]; θ=p[1])
    elseif t in [:CRn, :CRn̂]
        return op(
            string(t), sites[gate.control], sites[gate.target]; θ=p[1], ϕ=p[2], λ=p[3]
        )
    end
    return op(string(t), sites[gate.control], sites[gate.target])
end
function to_itensor_op(gate::TwoQubitGate, sites)
    return op(string(gate.gate_type), sites[gate.qubit1], sites[gate.qubit2])
end
function to_itensor_op(gate::ParametricTwoQubitGate, sites)
    t = gate.gate_type
    p = gate.params
    # Rxx, Ryy, Rzz は引数 ϕ を取る
    if t in [:Rxx, :Ryy, :Rzz, :RXX, :RYY, :RZZ]
        return op(string(t), sites[gate.qubit1], sites[gate.qubit2]; ϕ=p[1])
    end
    return op(string(t), sites[gate.qubit1], sites[gate.qubit2])
end

# --- Multi Qubit ---
function to_itensor_op(gate::ThreeQubitGate, sites)
    return op(
        string(gate.gate_type), sites[gate.qubit1], sites[gate.qubit2], sites[gate.qubit3]
    )
end
function to_itensor_op(gate::FourQubitGate, sites)
    return op(
        string(gate.gate_type),
        sites[gate.qubit1],
        sites[gate.qubit2],
        sites[gate.qubit3],
        sites[gate.qubit4],
    )
end

# --- N-Qubit Gates (General) ---
function to_itensor_op(gate::MultiQubitGate, sites)
    # Validate qubit indices
    for q in gate.qubits
        if q < 1 || q > length(sites)
            throw(
                ArgumentError(
                    "Qubit index $q is out of range [1, $(length(sites))]",
                ),
            )
        end
    end
    
    # Apply gate to specified qubits
    return op(string(gate.gate_type), [sites[q] for q in gate.qubits]...)
end

function to_itensor_op(gate::ParametricMultiQubitGate, sites)
    # Validate qubit indices
    for q in gate.qubits
        if q < 1 || q > length(sites)
            throw(
                ArgumentError(
                    "Qubit index $q is out of range [1, $(length(sites))]",
                ),
            )
        end
    end
    
    t = gate.gate_type
    p = gate.params
    
    # For now, assume the gate accepts standard parameter names
    # This can be extended based on specific gate requirements
    if length(p) == 1
        return op(string(t), [sites[q] for q in gate.qubits]...; θ=p[1])
    elseif length(p) == 2
        return op(string(t), [sites[q] for q in gate.qubits]...; θ=p[1], ϕ=p[2])
    elseif length(p) == 3
        return op(string(t), [sites[q] for q in gate.qubits]...; θ=p[1], ϕ=p[2], λ=p[3])
    else
        # For gates with arbitrary number of parameters, pass them as is
        return op(string(t), [sites[q] for q in gate.qubits]...)
    end
end

"""
    execute_circuit(circuit::QuantumCircuit, sites::Vector{<:Index}; init_state=nothing) -> MPS

Simulates the quantum circuit using ITensors.

# Arguments
- `circuit::QuantumCircuit`: The circuit object containing a sequence of gates.
- `sites::Vector{<:Index}`: The site indices (e.g., generated by `siteinds("Qubit", N)`).
- `init_state`: (Optional) Override initial state. Can be a single `String` (e.g., "0") 
  applied to all qubits, a `Vector{String}` for specific site states, or an `AbstractInitialState`.
  If `nothing`, uses `circuit.initial_states`.

# Returns
- `psi_final::MPS`: The resulting Matrix Product State after applying all gates.

# Throws
- `ArgumentError`: If circuit qubit count doesn't match sites count.
"""
function execute_circuit(circuit::QuantumCircuit, sites::Vector{<:Index}; init_state=nothing)
    if circuit.nqubits != length(sites)
        throw(
            ArgumentError(
                "Circuit qubit count ($(circuit.nqubits)) must match sites count ($(length(sites)))",
            ),
        )
    end
    
    # Determine initial state
    if init_state !== nothing
        # Use provided init_state (backward compatibility)
        if init_state isa AbstractInitialState
            state_vector = to_itensor_state(init_state, circuit.nqubits)
        elseif init_state isa String
            state_vector = init_state
        elseif init_state isa Vector{String}
            state_vector = init_state
        else
            throw(
                ArgumentError(
                    "init_state must be a String, Vector{String}, or AbstractInitialState",
                ),
            )
        end
    else
        # Use circuit's initial_states
        if length(circuit.initial_states) == 1
            # Single state specification for all qubits
            state_vector = to_itensor_state(circuit.initial_states[1], circuit.nqubits)
        else
            # Multiple state specifications (should match number of qubits)
            if length(circuit.initial_states) != circuit.nqubits
                throw(
                    ArgumentError(
                        "Number of initial_states ($(length(circuit.initial_states))) must match nqubits ($(circuit.nqubits)) or be 1",
                    ),
                )
            end
            state_vector = String[]
            for (i, state) in enumerate(circuit.initial_states)
                # For individual states, get the label for that qubit
                if state isa BasisState
                    push!(state_vector, state.label)
                elseif state isa NamedState
                    push!(state_vector, state.name)
                elseif state isa ProductState
                    throw(
                        ArgumentError(
                            "ProductState cannot be used in initial_states vector; use a single ProductState instead",
                        ),
                    )
                else
                    throw(ArgumentError("Unknown initial state type: $(typeof(state))"))
                end
            end
        end
    end
    
    ops = [to_itensor_op(g, sites) for g in circuit.gates]
    psi = MPS(sites, state_vector)
    psi_final = apply(ops, psi; cutoff=1e-15)
    return psi_final
end
export execute_circuit
