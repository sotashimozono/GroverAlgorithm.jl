"""
    to_itensor_op(gate::QuantumGate, sites)
convert a QuantumGate (SingleQubitGate, ControlledGate, etc.) to an ITensors operator using the provided site indices.
This function is overloaded for different gate types, allowing for a seamless mapping from our abstract gate representation to the concrete ITensor operators. The `sites` argument is expected to be a collection of site indices corresponding to the qubits in the circuit, typically obtained from `siteinds("Qubit", N)`.
The function handles various gate types, including single-qubit gates, controlled gates, and multi-qubit gates, as well as their parametric versions. It constructs the appropriate ITensor operator based on the gate type and its parameters, ensuring that the resulting operator can be directly applied to an MPS representing the quantum state.
"""
function to_itensor_op end
export to_itensor_op

# --- Single Qubit & Spin ---
function to_itensor_op(gate::SingleQubitGate, sites)
    return op(string(gate.gate_type), sites[gate.qubit])
end
function to_itensor_op(gate::ParametricSingleGate, sites)
    t = gate.gate_type
    p = gate.params
    if t in [:Rx, :Ry, :Rz, :RX, :RY, :RZ]
        return op(string(t), sites[gate.qubit]; θ=p[1])
    elseif t in [:Rn, :Rn̂]
        return op(string(t), sites[gate.qubit]; θ=p[1], ϕ=p[2], λ=p[3])
    elseif t in [:Phase, :P, :S]
        return op(string(t), sites[gate.qubit]; ϕ=p[1])
    end
    return op(string(t), sites[gate.qubit])
end

# --- Two Qubit ---
function to_itensor_op(gate::ControlledGate, sites)
    return op(string(gate.gate_type), sites[gate.control], sites[gate.target])
end
function to_itensor_op(gate::ParametricControlledGate, sites)
    t = gate.gate_type
    p = gate.params
    if t in [:CRx, :CRy, :CRz, :CRX, :CRY, :CRZ]
        return op(string(t), sites[gate.control], sites[gate.target]; θ=p[1])
    elseif t in [:CRn, :CRn̂]
        return op(
            string(t), sites[gate.control], sites[gate.target]; θ=p[1], ϕ=p[2], λ=p[3]
        )
    end
    return op(string(t), sites[gate.control], sites[gate.target])
end
function to_itensor_op(gate::TwoQubitGate, sites)
    return op(string(gate.gate_type), sites[gate.qubit1], sites[gate.qubit2])
end
function to_itensor_op(gate::ParametricTwoQubitGate, sites)
    t = gate.gate_type
    p = gate.params
    # Rxx, Ryy, Rzz は引数 ϕ を取る
    if t in [:Rxx, :Ryy, :Rzz, :RXX, :RYY, :RZZ]
        return op(string(t), sites[gate.qubit1], sites[gate.qubit2]; ϕ=p[1])
    end
    return op(string(t), sites[gate.qubit1], sites[gate.qubit2])
end

# --- Multi Qubit ---
function to_itensor_op(gate::ThreeQubitGate, sites)
    return op(
        string(gate.gate_type), sites[gate.qubit1], sites[gate.qubit2], sites[gate.qubit3]
    )
end
function to_itensor_op(gate::FourQubitGate, sites)
    return op(
        string(gate.gate_type),
        sites[gate.qubit1],
        sites[gate.qubit2],
        sites[gate.qubit3],
        sites[gate.qubit4],
    )
end

"""
    execute_circuit(circuit::QuantumCircuit, sites::Vector{<:Index}; init_state="0") -> MPS

Simulates the quantum circuit using ITensors.

# Arguments
- `circuit::QuantumCircuit`: The circuit object containing a sequence of gates.
- `sites::Vector{<:Index}`: The site indices (e.g., generated by `siteinds("Qubit", N)`).
- `init_state`: The initial state of each qubit. Can be a single `String` (e.g., "0") 
  applied to all, or a `Vector{String}` for specific site states.

# Returns
- `psi_final::MPS`: The resulting Matrix Product State after applying all gates.
"""
function execute_circuit(circuit::QuantumCircuit, sites::Vector{<:Index}; init_state="0")
    if circuit.nqubits != length(sites)
        throw(
            ArgumentError(
                "Circuit qubit count ($(circuit.nqubits)) must match sites count ($(length(sites)))",
            ),
        )
    end
    ops = [to_itensor_op(g, sites) for g in circuit.gates]
    psi = MPS(sites, init_state)
    psi_final = apply(ops, psi; cutoff=1e-15)
    return psi_final
end
export execute_circuit
