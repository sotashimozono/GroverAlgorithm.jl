var documenterSearchIndex = {"docs":
[{"location":"api/core/measurement/#AbstractMeasurement","page":"measurement","title":"AbstractMeasurement","text":"Here we define a struct which represents measurement.","category":"section"},{"location":"api/core/measurement/#Documents","page":"measurement","title":"Documents","text":"","category":"section"},{"location":"api/core/measurement/#GroverAlgorithm.AbstractMeasurement","page":"measurement","title":"GroverAlgorithm.AbstractMeasurement","text":"AbstractMeasurement\n\nAbstract type for quantum measurements performed on MPS after circuit execution. Encapsulates different measurement strategies for quantum states.\n\n\n\n\n\n","category":"type"},{"location":"api/core/measurement/#GroverAlgorithm.ExpectationValue","page":"measurement","title":"GroverAlgorithm.ExpectationValue","text":"ExpectationValue(operator::Symbol, qubits::Vector{Int})\n\nRepresents an expectation value measurement of a physical operator.\n\nComputes ⟨ψ|Ô|ψ⟩ where Ô is the specified operator acting on the given qubits.\n\nFields\n\noperator::Symbol: The operator symbol (e.g., :X, :Y, :Z, :H, :Sz).\nqubits::Vector{Int}: The qubit indices where the operator acts (1-based).\n\nExample\n\nExpectationValue(:Z, [1])  # Measure ⟨Z⟩ on qubit 1\nExpectationValue(:X, [1, 2])  # Measure ⟨X₁X₂⟩ on qubits 1 and 2\n\n\n\n\n\n","category":"type"},{"location":"api/core/measurement/#GroverAlgorithm.ProjectiveMeasurement","page":"measurement","title":"GroverAlgorithm.ProjectiveMeasurement","text":"ProjectiveMeasurement(qubit::Int)\n\nRepresents a projective measurement on a specific qubit.\n\nMeasures a single qubit in the computational basis and collapses the state.\n\nFields\n\nqubit::Int: The qubit index to measure (1-based).\n\nExample\n\nProjectiveMeasurement(1)  # Measure qubit 1\n\n\n\n\n\n","category":"type"},{"location":"api/core/measurement/#GroverAlgorithm.Sampling","page":"measurement","title":"GroverAlgorithm.Sampling","text":"Sampling(shots::Int)\n\nRepresents a sampling measurement in the computational basis.\n\nPerforms repeated measurements to obtain a probability distribution over basis states.\n\nFields\n\nshots::Int: The number of measurement samples to collect.\n\nExample\n\nSampling(1000)  # Perform 1000 measurements\n\n\n\n\n\n","category":"type"},{"location":"api/ITensorIO/get_gate/#convert-itensor-gate","page":"Get Gate","title":"convert itensor gate","text":"From AbstractQuantumGate object, you can obtain gate defined in ITensorMPS.jl. Available gates are same as ones in ITensorMPS.jl","category":"section"},{"location":"api/ITensorIO/get_gate/#Documents","page":"Get Gate","title":"Documents","text":"","category":"section"},{"location":"api/ITensorIO/get_gate/#GroverAlgorithm.execute_circuit-Tuple{QuantumCircuit, Vector{<:Index}}","page":"Get Gate","title":"GroverAlgorithm.execute_circuit","text":"execute_circuit(circuit::QuantumCircuit, sites::Vector{<:Index}; init_state=nothing) -> MPS\n\nSimulates the quantum circuit using ITensors.\n\nArguments\n\ncircuit::QuantumCircuit: The circuit object containing a sequence of gates.\nsites::Vector{<:Index}: The site indices (e.g., generated by siteinds(\"Qubit\", N)).\ninit_state: (Optional) Override initial state. Can be a single String (e.g., \"0\")  applied to all qubits, a Vector{String} for specific site states, or an AbstractInitialState. If nothing, uses circuit.initial_states.\n\nReturns\n\npsi_final::MPS: The resulting Matrix Product State after applying all gates.\n\nThrows\n\nArgumentError: If circuit qubit count doesn't match sites count.\n\n\n\n\n\n","category":"method"},{"location":"api/ITensorIO/get_gate/#GroverAlgorithm.to_itensor_op","page":"Get Gate","title":"GroverAlgorithm.to_itensor_op","text":"to_itensor_op(gate::QuantumGate, sites)\n\nconvert a QuantumGate (SingleQubitGate, ControlledGate, etc.) to an ITensors operator using the provided site indices. This function is overloaded for different gate types, allowing for a seamless mapping from our abstract gate representation to the concrete ITensor operators. The sites argument is expected to be a collection of site indices corresponding to the qubits in the circuit, typically obtained from siteinds(\"Qubit\", N). The function handles various gate types, including single-qubit gates, controlled gates, and multi-qubit gates, as well as their parametric versions. It constructs the appropriate ITensor operator based on the gate type and its parameters, ensuring that the resulting operator can be directly applied to an MPS representing the quantum state.\n\n\n\n\n\n","category":"function"},{"location":"api/QuantikzIO/quantikz/#QuantikzPicture","page":"Quantikz Output","title":"QuantikzPicture","text":"Here we define methods which converts QuantumCircuit object into quantikz picture. It returns object in TikzPicture.jl. Please refer its document to save pictures.","category":"section"},{"location":"api/QuantikzIO/quantikz/#Documents","page":"Quantikz Output","title":"Documents","text":"","category":"section"},{"location":"api/QuantikzIO/quantikz/#GroverAlgorithm.add_gate_column!","page":"Quantikz Output","title":"GroverAlgorithm.add_gate_column!","text":"add_gate_column!(qubit_lines::Vector{Vector{String}}, gate::AbstractQuantumGate, nqubits::Int)\n\nAdds a single \"time slice\" (column) of the given gate to all qubit lines in the circuit.\n\nqubit_lines: A vector of string vectors, where each sub-vector represents the sequence of LaTeX commands for a specific qubit.\ngate: The quantum gate object to be converted and added.\nnqubits: Total number of qubits in the circuit.\n\nthe function determines the type of the gate and appends the appropriate LaTeX command to the corresponding qubit lines:\n\nFor the qubit(s) acted upon by the gate, appropriate LaTeX commands (like \\gate, \\ctrl, \\targ) are appended.\nFor all other qubits, a wire command (\\qw) is appended to maintain column alignment across the circuit.\n\n\n\n\n\n","category":"function"},{"location":"api/QuantikzIO/quantikz/#GroverAlgorithm.build_circuit_matrix_packed-Tuple{QuantumCircuit}","page":"Quantikz Output","title":"GroverAlgorithm.build_circuit_matrix_packed","text":"build_circuit_matrix_packed(circuit::QuantumCircuit) -> Vector{Vector{String}}\n\nBuilds the circuit representation using the packed layout. Gates that don't interfere with each other are placed in the same column.\n\n\n\n\n\n","category":"method"},{"location":"api/QuantikzIO/quantikz/#GroverAlgorithm.build_circuit_matrix_serial-Tuple{QuantumCircuit}","page":"Quantikz Output","title":"GroverAlgorithm.build_circuit_matrix_serial","text":"build_circuit_matrix_serial(circuit::QuantumCircuit) -> Vector{Vector{String}}\n\nBuilds the circuit representation using the serial layout (original behavior). Each gate occupies its own column.\n\n\n\n\n\n","category":"method"},{"location":"api/QuantikzIO/quantikz/#GroverAlgorithm.get_involved_qubits","page":"Quantikz Output","title":"GroverAlgorithm.get_involved_qubits","text":"get_involved_qubits(gate::AbstractQuantumGate) -> (Int, Int)\n\nReturns the range of qubits that a gate visually occupies (min, max). For gates like CNOT, this includes all qubits between control and target, as the control line visually crosses intermediate qubits.\n\n\n\n\n\n","category":"function"},{"location":"api/QuantikzIO/quantikz/#GroverAlgorithm.get_latex_commands","page":"Quantikz Output","title":"GroverAlgorithm.get_latex_commands","text":"get_latex_commands(gate::AbstractQuantumGate, nqubits::Int) -> Vector{String}\n\nReturns a vector of LaTeX commands for all qubits for the given gate. The vector has length nqubits, where each element is the LaTeX command for that qubit line (e.g., \"\\gate{H}\", \"\\ctrl{2}\", \"\\qw\", etc.).\n\n\n\n\n\n","category":"function"},{"location":"api/QuantikzIO/quantikz/#GroverAlgorithm.to_quantikz-Tuple{QuantumCircuit}","page":"Quantikz Output","title":"GroverAlgorithm.to_quantikz","text":"to_quantikz(circuit::QuantumCircuit; layout::Symbol=:packed) -> String\n\nGenerates a complete LaTeX string wrapped in a quantikz environment.\n\nArguments\n\ncircuit::QuantumCircuit: The quantum circuit to visualize.\nlayout::Symbol: Layout mode for the circuit.\n:serial (or :horizontal): One gate per column (original behavior).\n:packed (or :parallel, :vertical): Pack non-overlapping gates in the same column (default).\n\nThis function:\n\nIterates through all gates in the circuit.\nBuilds an internal representation of columns for each qubit.\nUses initial state labels from circuit.initial_states for qubit labels.\nJoins the commands with & separators and wraps them in LaTeX boilerplate.\n\nReturns\n\nA String containing the full LaTeX source code.\n\n\n\n\n\n","category":"method"},{"location":"api/QuantikzIO/quantikz/#GroverAlgorithm.to_tikz_picture-Tuple{QuantumCircuit}","page":"Quantikz Output","title":"GroverAlgorithm.to_tikz_picture","text":"to_tikz_picture(circuit::QuantumCircuit; layout::Symbol=:packed) -> TikzPicture\n\nConvert a QuantumCircuit object into a TikzPicture that represents the quantum circuit diagram using the quantikz LaTeX package.\n\nArguments\n\ncircuit::QuantumCircuit: The quantum circuit to visualize.\nlayout::Symbol: Layout mode for the circuit.\n:serial (or :horizontal): One gate per column (original behavior).\n:packed (or :parallel, :vertical): Pack non-overlapping gates in the same column (default).\n\nThe function processes each gate in the circuit and constructs the corresponding LaTeX code for each qubit line,  using initial state labels from circuit.initial_states, ensuring proper alignment and formatting for multi-qubit gates. The resulting TikzPicture can be rendered in LaTeX documents to visualize the quantum circuit.\n\n\n\n\n\n","category":"method"},{"location":"api/core/qubit/#AbstractQuantumState","page":"qubit","title":"AbstractQuantumState","text":"Here we define a struct which represents initial quantum states. By using these definitions, it reflected not only in QuantumCircuit calculation but also in quantikz picture. Available states are common to ITensorMPS.jl.","category":"section"},{"location":"api/core/qubit/#Documents","page":"qubit","title":"Documents","text":"","category":"section"},{"location":"api/core/qubit/#GroverAlgorithm.AbstractInitialState","page":"qubit","title":"GroverAlgorithm.AbstractInitialState","text":"AbstractInitialState\n\nAbstract type for quantum initial states in a quantum circuit. Provides common interfaces for both ITensors MPS initialization and quantikz visualization.\n\n\n\n\n\n","category":"type"},{"location":"api/core/qubit/#GroverAlgorithm.BasisState","page":"qubit","title":"GroverAlgorithm.BasisState","text":"BasisState(label::String)\n\nRepresents a computational basis state for quantum circuit initialization.\n\nFields\n\nlabel::String: The state label conforming to ITensors' op-defined state names. Common values include \"0\", \"1\", \"+\", \"-\", \"Up\", \"Dn\", etc.\n\nExample\n\nBasisState(\"0\")  # |0⟩ state\nBasisState(\"+\")  # |+⟩ state (equal superposition)\n\n\n\n\n\n","category":"type"},{"location":"api/core/qubit/#GroverAlgorithm.NamedState","page":"qubit","title":"GroverAlgorithm.NamedState","text":"NamedState(name::String, latex::String)\n\nRepresents a quantum state with arbitrary name and LaTeX label for visualization.\n\nFields\n\nname::String: The state name for ITensors initialization (must be a valid ITensors state).\nlatex::String: The LaTeX representation for quantikz visualization.\n\nExample\n\nNamedState(\"0\", \"\\psi_0\")  # Initialized as |0⟩ but displayed as |ψ₀⟩\n\n\n\n\n\n","category":"type"},{"location":"api/core/qubit/#GroverAlgorithm.ProductState","page":"qubit","title":"GroverAlgorithm.ProductState","text":"ProductState(labels::Vector{String})\n\nRepresents a product state where each qubit is individually specified.\n\nFields\n\nlabels::Vector{String}: Vector of state labels, one for each qubit. Each label should conform to ITensors' op-defined state names.\n\nUsage\n\nProductState is typically used as a single element in the initial_states vector to specify all qubits at once. To specify different states per qubit individually, use a vector of BasisState or NamedState instances instead.\n\nExamples\n\n# Use ProductState as a single element for all qubits:\ninitial = AbstractInitialState[ProductState([\"0\", \"1\", \"+\"])]\ncircuit = QuantumCircuit(3, AbstractQuantumGate[], initial)\n\n# To specify per-qubit states individually, use BasisState:\ninitial = AbstractInitialState[BasisState(\"0\"), BasisState(\"1\"), BasisState(\"+\")]\ncircuit = QuantumCircuit(3, AbstractQuantumGate[], initial)\n\n\n\n\n\n","category":"type"},{"location":"api/core/qubit/#GroverAlgorithm.to_itensor_state-Tuple{BasisState, Int64}","page":"qubit","title":"GroverAlgorithm.to_itensor_state","text":"to_itensor_state(state::AbstractInitialState, nqubits::Int) -> Vector{String}\n\nConvert an initial state specification to a vector of state strings for ITensors MPS initialization.\n\nArguments\n\nstate::AbstractInitialState: The initial state specification.\nnqubits::Int: The total number of qubits in the circuit.\n\nReturns\n\nVector{String}: A vector of state strings suitable for MPS(sites, states).\n\nThrows\n\nArgumentError: If the state specification is incompatible with the number of qubits.\n\nExample\n\nto_itensor_state(BasisState(\"0\"), 3)  # [\"0\", \"0\", \"0\"]\nto_itensor_state(ProductState([\"0\", \"1\"]), 2)  # [\"0\", \"1\"]\n\n\n\n\n\n","category":"method"},{"location":"api/core/qubit/#GroverAlgorithm.to_latex_label-Tuple{BasisState, Int64}","page":"qubit","title":"GroverAlgorithm.to_latex_label","text":"to_latex_label(state::AbstractInitialState, qubit_idx::Int) -> String\n\nGenerate a LaTeX label for the specified qubit in quantikz visualization.\n\nArguments\n\nstate::AbstractInitialState: The initial state specification.\nqubit_idx::Int: The index of the qubit (1-based).\n\nReturns\n\nString: A LaTeX string for use in \\lstick{}.\n\nExample\n\nto_latex_label(BasisState(\"0\"), 1)  # \"\\ket{0}\"\nto_latex_label(NamedState(\"0\", \"\\psi\"), 1)  # \"\\ket{\\psi}\"\n\n\n\n\n\n","category":"method"},{"location":"api/ITensorIO/measure/#Measurement-Methods","page":"Measurements","title":"Measurement Methods","text":"Methods related to Measurement like Projection or Expectation Value.","category":"section"},{"location":"api/ITensorIO/measure/#Documents","page":"Measurements","title":"Documents","text":"","category":"section"},{"location":"api/ITensorIO/measure/#GroverAlgorithm.measure-Tuple{MPS, ExpectationValue}","page":"Measurements","title":"GroverAlgorithm.measure","text":"measure(mps::MPS, m::AbstractMeasurement) -> Any\n\nExecute a measurement on the given Matrix Product State.\n\nArguments\n\nmps::MPS: The quantum state as an MPS.\nm::AbstractMeasurement: The measurement specification.\n\nReturns\n\nThe return type depends on the measurement:\n\nExpectationValue: Returns Float64 or ComplexF64 - the expectation value.\nSampling: Returns Dict{String, Int} - counts for each basis state.\nProjectiveMeasurement: Returns Tuple{Int, MPS} - the measurement outcome (0 or 1) and collapsed state.\n\nThrows\n\nArgumentError: If qubit indices are out of range or measurement is invalid.\n\nNotes\n\nFor multi-qubit ExpectationValue, the operator acts as a tensor product on the specified qubits.\n\nExample\n\nsites = siteinds(\"Qubit\", 2)\npsi = MPS(sites, [\"0\", \"0\"])\nresult = measure(psi, ExpectationValue(:Z, [1]))\n\n\n\n\n\n","category":"method"},{"location":"api/core/gates/#AbstractQuantumGate","page":"gates","title":"AbstractQuantumGate","text":"Here we define a struct which represents quantum gates. Available gates are common to ITensorMPS.jl. you need to take care that in ITensorMPS gatetype are spacified by String but here only symbols are available. Especially, QuantumCircuit object is a key function.","category":"section"},{"location":"api/core/gates/#Documents","page":"gates","title":"Documents","text":"","category":"section"},{"location":"api/core/gates/#GroverAlgorithm.AbstractQuantumGate","page":"gates","title":"GroverAlgorithm.AbstractQuantumGate","text":"AbstractQuantumGate\n\nAbstract type for quantum gates in the quantum circuit representation. Provides common interfaces between ITensors calcurations and quantikz representations. Available gates in ITensor Library\n\n\n\n\n\n","category":"type"},{"location":"api/core/gates/#GroverAlgorithm.ControlledGate","page":"gates","title":"GroverAlgorithm.ControlledGate","text":"ControlledGate(control::Int, target::Int, gate_type::Symbol)\n\nTwo-qubit controlled gate without parameters. gate_type specifies the operation applied to the target qubit. Available types include:\n\n:CNOT: Controlled-NOT gate (alias: :CX)\n:CY, :CZ: Controlled-Y and Controlled-Z gates\n:CPHASE: Controlled-Phase gate\n\n\n\n\n\n","category":"type"},{"location":"api/core/gates/#GroverAlgorithm.FourQubitGate","page":"gates","title":"GroverAlgorithm.FourQubitGate","text":"FourQubitGate(qubit1::Int, qubit2::Int, qubit3::Int, qubit4::Int, gate_type::Symbol)\n\nFour-qubit gate acting on the specified qubits. Available gate_type include:\n\n:CCCNOT: Triple-controlled NOT gate\n\n\n\n\n\n","category":"type"},{"location":"api/core/gates/#GroverAlgorithm.MultiQubitGate","page":"gates","title":"GroverAlgorithm.MultiQubitGate","text":"MultiQubitGate(qubits::Vector{Int}, gate_type::Symbol)\n\nGeneral n-qubit gate acting on an arbitrary number of qubits. This allows for gates acting on more than 4 qubits or custom multi-qubit operations.\n\nFields\n\nqubits::Vector{Int}: Vector of qubit indices (1-based) that the gate acts on.\ngate_type::Symbol: The type of gate to apply.\n\nExamples\n\n# 5-qubit controlled gate\ngate = MultiQubitGate([1, 2, 3, 4, 5], :C4NOT)\n\n# Custom multi-qubit gate\ngate = MultiQubitGate([1, 3, 5, 7], :CustomGate)\n\nNotes\n\nThe interpretation of gate_type depends on the number of qubits and the specific gate.\nFor standard gates with 1-4 qubits, prefer using the specific gate types for clarity.\nThis is useful for gates with 5 or more qubits, or for custom multi-qubit operations.\n\n\n\n\n\n","category":"type"},{"location":"api/core/gates/#GroverAlgorithm.ParametricControlledGate","page":"gates","title":"GroverAlgorithm.ParametricControlledGate","text":"ParametricControlledGate(control::Int, target::Int, gate_type::Symbol, params::Vector{Float64})\n\nTwo-qubit controlled gate with parameters. Available gate_type include:\n\n:CRx, :CRy, :CRz: Controlled rotation gates (argument: [θ])\n:CRn: Controlled rotation about an arbitrary axis (arguments: [θ, ϕ, λ])\n\n\n\n\n\n","category":"type"},{"location":"api/core/gates/#GroverAlgorithm.ParametricMultiQubitGate","page":"gates","title":"GroverAlgorithm.ParametricMultiQubitGate","text":"ParametricMultiQubitGate(qubits::Vector{Int}, gate_type::Symbol, params::Vector{Float64})\n\nGeneral n-qubit parametric gate acting on an arbitrary number of qubits with parameters.\n\nFields\n\nqubits::Vector{Int}: Vector of qubit indices (1-based) that the gate acts on.\ngate_type::Symbol: The type of gate to apply.\nparams::Vector{Float64}: Parameters for the gate (e.g., rotation angles).\n\nExamples\n\n# Multi-qubit rotation gate\ngate = ParametricMultiQubitGate([1, 2, 3], :MultiRz, [π/4])\n\n# Custom parametric gate\ngate = ParametricMultiQubitGate([1, 3, 5], :CustomRotation, [π/2, π/4, π/8])\n\n\n\n\n\n","category":"type"},{"location":"api/core/gates/#GroverAlgorithm.ParametricSingleGate","page":"gates","title":"GroverAlgorithm.ParametricSingleGate","text":"ParametricSingleGate(qubit::Int, gate_type::Symbol, params::Vector{Float64})\n\nQuantum gate acting on a single qubit with one or more parameters. params is a vector of parameters such as rotation angles (e.g., theta phi lambda). Available gate_type include:\n\n:Rx, :Ry, :Rz: Rotation gates around the x, y, and z axes (argument: [θ])\n:Rn: Rotation about an arbitrary axis n=(theta phi lambda) (arguments: [θ, ϕ, λ])\n\n\n\n\n\n","category":"type"},{"location":"api/core/gates/#GroverAlgorithm.ParametricTwoQubitGate","page":"gates","title":"GroverAlgorithm.ParametricTwoQubitGate","text":"ParametricTwoQubitGate(qubit1::Int, qubit2::Int, gate_type::Symbol, params::Vector{Float64})\n\nTwo-qubit gate with parameters, typically used for coupling operations. Available gate_type include:\n\n:Rxx, :Ryy, :Rzz: Ising (XX, YY, ZZ) coupling gates (argument: [ϕ])\n\n\n\n\n\n","category":"type"},{"location":"api/core/gates/#GroverAlgorithm.QuantumCircuit","page":"gates","title":"GroverAlgorithm.QuantumCircuit","text":"QuantumCircuit\n\nRepresents a quantum circuit consisting of a fixed number of qubits and a sequence of gates.\n\nFields\n\nnqubits::Int: The total number of qubits in the circuit.\ngates::Vector{AbstractQuantumGate}: A list of quantum gates to be applied sequentially.\ninitial_states::Vector{AbstractInitialState}: Initial state specification for each qubit. Defaults to [BasisState(\"0\")] for all qubits if not specified.\n\nInitial States Usage\n\nThe initial_states field can be specified in two ways:\n\nSingle state for all qubits: Use a vector with one element\ninitial = AbstractInitialState[BasisState(\"0\")]  # All qubits in |0⟩\ninitial = AbstractInitialState[ProductState([\"0\", \"1\", \"+\"])]  # Qubits in |0⟩, |1⟩, |+⟩\nPer-qubit states: Use a vector with one element per qubit\ninitial = AbstractInitialState[BasisState(\"0\"), BasisState(\"1\")]  # First qubit |0⟩, second |1⟩\n\nNote: ProductState should be used as a single element, not within a multi-element vector.\n\n\n\n\n\n","category":"type"},{"location":"api/core/gates/#GroverAlgorithm.SingleQubitGate","page":"gates","title":"GroverAlgorithm.SingleQubitGate","text":"SingleQubitGate(qubit::Int, gate_type::Symbol)\n\nQuantum gate acting on a single qubit without parameters. gate_type specifies the type of gate. Available types include:\n\n:X, :Y, :Z: Pauli operators\n:H: Hadamard gate\n:S, :T: Phase shift gates (aliases: :Phase, :π/8)\n:Proj0, :Proj1: Projection operators (0ranglelangle0 and 1ranglelangle1)\n\n\n\n\n\n","category":"type"},{"location":"api/core/gates/#GroverAlgorithm.ThreeQubitGate","page":"gates","title":"GroverAlgorithm.ThreeQubitGate","text":"ThreeQubitGate(qubit1::Int, qubit2::Int, qubit3::Int, gate_type::Symbol)\n\nThree-qubit gate acting on the specified qubits. Available gate_type include:\n\n:Toffoli: Controlled-Controlled-NOT gate (aliases: :CCNOT, :CCX)\n:Fredkin: Controlled-SWAP gate (alias: :CSWAP)\n\n\n\n\n\n","category":"type"},{"location":"api/core/gates/#GroverAlgorithm.TwoQubitGate","page":"gates","title":"GroverAlgorithm.TwoQubitGate","text":"TwoQubitGate(qubit1::Int, qubit2::Int, gate_type::Symbol)\n\nTwo-qubit gate without a specific control/target structure. Available gate_type include:\n\n:SWAP: Swap gate\n:iSWAP: Imaginary Swap gate\n:√SWAP: Square root of Swap gate\n\n\n\n\n\n","category":"type"},{"location":"api/core/gates/#GroverAlgorithm.add_gate!-Tuple{QuantumCircuit, AbstractQuantumGate}","page":"gates","title":"GroverAlgorithm.add_gate!","text":"add_gate!(circuit::QuantumCircuit, gate::AbstractQuantumGate)\n\nAppends a quantum gate to the end of the circuit's gate sequence. Returns the modified QuantumCircuit object to allow for method chaining.\n\n\n\n\n\n","category":"method"},{"location":"api/core/gates/#GroverAlgorithm.set_state!-Tuple{QuantumCircuit, Vector{AbstractInitialState}}","page":"gates","title":"GroverAlgorithm.set_state!","text":"set_state!(circuit::QuantumCircuit, initial_states::Vector{AbstractInitialState})\n\nSets the initial state of the quantum circuit. This replaces any existing initial state specification. Returns the modified QuantumCircuit object to allow for method chaining.\n\n\n\n\n\n","category":"method"},{"location":"#GroverAlgorithm.jl","page":"Home","title":"GroverAlgorithm.jl","text":"Julia Module for simulating and visualizing quantum circuit. As a backend, ITensors.jl/ITensorMPS.jl and Quantikz are required.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Quantum Gates: Wide range of gates from 1-qubit to 4-qubit operations\nInitial State Abstraction: Support for computational basis, custom labels, and product states\nMeasurements: Expectation values, sampling, and projective measurements\nITensors Integration: Efficient simulation using Matrix Product States (MPS)\nQuantikz Visualization: Beautiful circuit diagrams via LaTeX/TikZ","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using GroverAlgorithm\nusing ITensors, ITensorMPS\n\n# Create a Bell state circuit\ncircuit = QuantumCircuit(2, AbstractQuantumGate[])\nadd_gate!(circuit, SingleQubitGate(1, :H))\nadd_gate!(circuit, ControlledGate(1, 2, :CNOT))\n\n# Simulate with ITensors\nsites = siteinds(\"Qubit\", 2)\npsi = execute_circuit(circuit, sites)\n\n# Measure\ncounts = measure(psi, Sampling(1000))\nprintln(counts)  # Dict(\"00\" => ~500, \"11\" => ~500)\n\n# Visualize\n# tp = to_quantikz(circuit) : quantikz src\ntp = to_tikz_picture(circuit)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/sotashimozono/GroverAlgorithm.jl\")","category":"section"},{"location":"#Related-Links","page":"Home","title":"Related Links","text":"GitHub Repository\nITensors.jl Documentation\nQuantikz Package","category":"section"},{"location":"api/QuantikzIO/latexstrings/#LaTeXStrings","page":"latex strings","title":"LaTeXStrings","text":"Here we define methods which converts QuantumCircuit object into quantikz LaTeX source code. When you want Quantikz Picture directly, refer quantikz page.","category":"section"},{"location":"api/QuantikzIO/latexstrings/#Documents","page":"latex strings","title":"Documents","text":"","category":"section"},{"location":"api/QuantikzIO/latexstrings/#GroverAlgorithm.controlled_gate_target-Tuple{Symbol}","page":"latex strings","title":"GroverAlgorithm.controlled_gate_target","text":"controlled_gate_target(gate_type::Symbol) -> String\n\nGiven a gate type symbol, return the appropriate LaTeX string for the target part of a controlled gate in a quantum circuit diagram.\n\nFor :X, :CNOT, :CX, it returns \\targ{}.\nFor :Z, :CZ, it returns \\ctrl{0}.\nFor :Y, :CY, it returns \\gate{Y}.\nFor :CPHASE, :Cphase, it returns \\ctrl{0}.\nFor other gate types, it returns \\gate{<LaTeX representation of the gate>} using the gate_to_latex function.\n\n\n\n\n\n","category":"method"},{"location":"api/QuantikzIO/latexstrings/#GroverAlgorithm.format_param-Tuple{Real}","page":"latex strings","title":"GroverAlgorithm.format_param","text":"format_param(θ::Real) -> String\n\nConvert a rotation angle θ (in radians) to a LaTeX-friendly string representation.\n\nIf θ is a multiple of π, it returns a string like \"π\", \"2π\", \"-π\", etc.\nIf θ is a rational multiple of π (e.g., π/2, π/4), it returns a string like \"π/2\", \"π/4\", etc.\nFor other values, it returns a decimal representation rounded to 3 decimal places.\n\n\n\n\n\n","category":"method"},{"location":"api/QuantikzIO/latexstrings/#GroverAlgorithm.gate_to_latex-Tuple{Symbol, AbstractVector{<:Real}}","page":"latex strings","title":"GroverAlgorithm.gate_to_latex","text":"gate_to_latex(gate_type::Symbol, params::AbstractVector{<:Real}) -> String\n\nConvert a parameterized gate type symbol and its parameters to a LaTeX string representation for visualization in quantum circuit diagrams. Supported parameterized gate types include:\n\nSingle-qubit rotation gates: :Rx, :Ry, :Rz, :Rn\nControlled rotation gates: :CRx, :CRy, :CRz, :CRn\nTwo-qubit rotation gates: :Rxx, :Ryy, :Rzz\nPhase gates: :Phase, :P, :S\n\nIf the gate type is not recognized, it returns the string representation of the symbol along with its parameters in parentheses.\n\n\n\n\n\n","category":"method"},{"location":"api/QuantikzIO/latexstrings/#GroverAlgorithm.gate_to_latex-Tuple{Symbol}","page":"latex strings","title":"GroverAlgorithm.gate_to_latex","text":"gate_to_latex(gate_type::Symbol) -> String\n\nConvert a gate type symbol to its corresponding LaTeX string representation for visualization in quantum circuit diagrams. Supported gate types include:\n\nSingle-qubit gates: :X, :Y, :Z, :H, :T, :S, :Phase, :P, :Proj0, :Proj1, etc.\nTwo-qubit gates: :CNOT, :CY, :CZ, :CPHASE, :SWAP, :iSWAP, etc.\nThree-qubit gates: :Toffoli, :Fredkin, etc.\nFour-qubit gates: :CCCNOT, etc.\n\nIf the gate type is not recognized, it returns the string representation of the symbol itself.\n\n\n\n\n\n","category":"method"}]
}
